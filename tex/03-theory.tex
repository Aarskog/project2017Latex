\chapter{Kinematics, Inverse Kinematics and Control}

Now that a functioning simulation environment is created a control hierarchy is needed. The initial thought is a multivariable control on top on single joint control. The multivariable control is done in Python or Matlab. The multivariable control will use the joint positions and joint velocities to compute the desired joint torques which is sent to joint PID controllers which is handled by using ROS control package. The first thing to do is therefore to create the individual joint PID controllers. 
To create these controllers two new files are needed. A new launch file must be created. It is possible to just append the launch file, but to make everything more understandable and if the package is to be used on the real robot it is easier to make a new launch file that can be included in other launch files. The task of the control.launch file is to spawn a node which includes all of the five controllers. In \lstref{lst:launchControl} one can see the the code to spawn the controllers. It consists of two statements. The first is loading the parameters of the controllers from the YAML file. Then with the parameters loaded, a node is created and it makes the joint controller services that the wanted joint torques can be published to. 
\begin{lstlisting}[language=xml,caption={Spawns the controller node},label={lst:launchControl}]
<rosparam file="$(find five_dof_robotarm)/config/joints.yaml" command="load"/>

  <node name="controller_spawner" pkg="controller_manager" type="spawner" respawn="false"
	output="screen" ns="/five_dof_robotarm" args="joint_state_controller
    base_to_turntable_controller
    second_joint_controller
    third_joint_controller
    fourth_joint_controller
    fifth_joint_controller"/>
\end{lstlisting}
Below in \lstref{lst:pythonPubl} one can see how the publishers that will publish the desired joint torques calculated by the controller. 
\begin{lstlisting}[language=python,caption={Python code for creating the publishers.},label={lst:pythonPubl}]
#Define publishers for each joint position controller commands.
pub1 = rospy.Publisher('/five_dof_robotarm/first_joint_controller/command', Float64, queue_size=10)
pub2 = rospy.Publisher('/five_dof_robotarm/second_joint_controller/command', Float64, queue_size=10)
pub3 = rospy.Publisher('/five_dof_robotarm/third_joint_controller/command', Float64, queue_size=10)
pub4 = rospy.Publisher('/five_dof_robotarm/fourth_joint_controller/command', Float64, queue_size=10)
pub5 = rospy.Publisher('/five_dof_robotarm/fifth_joint_controller/command', Float64, queue_size=10)
\end{lstlisting}

And how to publish the wanted torques is seen below in \lstref{lst:pythonPubs}. Here $u$ is the vector of the controller output. During the project it was also wanted to do the same in Matlab and the initial thought is the same and can be viewed in the appendix. 

\begin{lstlisting}[language=python,caption={Python code for publish wanted torques},label={lst:pythonPubs}]
pub1.publish(u[0,0])
pub2.publish(u[1,0])
pub3.publish(u[2,0])
pub4.publish(u[3,0])
pub5.publish(u[4,0])
\end{lstlisting}

Another important functionallity to do control is to get the feedback from Gazebo with joint position and joint velocities. To do this a subscriber is needed. The subscriber can thought of as the opposite as the publisher. Instead of publishing values to a service, we now want to listen to a service. 


\section{Control}

\subsection{PD controller with gravity compensation}

The controller that is going to be used is a simple PD controller with gravity compensation derived by \cite{spong}:
$$
    u=K_p\tilde{q} - K_d\dot{q} +g(q)
$$
 where $\tilde{q} = q_d - q$ and 
 \begin{align}\label{eq:gravity}
 g(q) = \frac{\partial P}{\partial q_k}
 \end{align}
 where the total potential energy for a n-link robot is $P = \sum^n_{i=1}P_i$. Where $P_i$ is the potential energy for each individual link. For this specific manipulator the center of mass is assumed in the geometric center of each link. In \cite{Siciliano} this controller is proven by using Lyapunov direct method to be globally asymptotically stable(GAS) as long as $K_d$ and $K_p$ is positive definite. It is important to keep in mind that if the online computing of $g(q)$ is not perfect, the statement of GAS does not hold. Based on the assumptions made, the controller can not guarantee GAS. 
 
 \subsection{Deriving the gravitational effect}
 The robot at hand starts and ends with twisting joints and only the three joints in the middle is rotational joints. This means that the potential energy is only dependent on $q_2$,$q_3$ and $q_4$ which makes calculating the potential energy a bit a easier. Because of this, the potential energy can be calculated by using a 2D sketch as shown in \figref{draw:pot-rob}.

\begin{figure}[htbp]
    \centering
    \input{tex/drawing/robotarm.tex}
    \caption{Sketch of the robot the three middle joints of the robot}
    \label{draw:pot-rob}
\end{figure}
     
In \eqref{eq:potE} the potential energy is calculated for each link in the robot. 
 \begin{align}
    \begin{split}\label{eq:potE}
        P_1 &= m_1g\frac{L_1}{2}
        \\
        P_2 &= m_2g\left(L_1 + \frac{L_2}{2}\cos{(q_2)}\right)
        \\
        P_3 &= m_3g\left(L_1 +  L_2 \cos{(q_2)} + \frac{L_3}{2}\cos{(q_2 + q_3)} \right)
        \\
        P_4 &= m_4g\left(L_1 +  L_2 \cos{(q_2)} + L_3\cos{(q_2 + q_3)} + \frac{L_4}{2}\cos{(q_2+q_3+q_4)} \right)
        \\
        P_5 &=m_5g\left(L_1 +  L_2 \cos{(q_2)} + L_3\cos{(q_2 + q_3)} + \left(L_4 + \frac{L_5}{2} \right)\cos{(q_2+q_3+q_4)} \right)
        \\
        P &= P_1 + P_2 + P_3 + P_4 + P_5
    \end{split}   
 \end{align}    


 Where $L_4$ is the part up to the rotational joint. $L_5$ and $m_5$ is the rotational joint and the gripper together.  \\
 
 And then, to calculate individual gravity components equation \eqref{eq:gravity} is used on \eqref{eq:potE}:

 \begin{align*}
    g_1 &= 0
    \\
    g_2 &= \frac{\partial P}{\partial q_2} = 
    m_2g\frac{L_2}{2}\sin{(q_2)}+
    m_3g\left( L_2 \sin{(q_2)} + \frac{L_3}{2}\sin{(q_2+q_3)} \right)\\&+
    m_4g\left( L_2 \sin{(q_2)} + L_3\sin{(q_2 + q_3)} + \frac{L_4}{2}\sin{(q_2+q_3+q_4)} \right)\\&+
    m_5g\left( L_2 \sin{(q_2)} + L_3\sin{(q_2 + q_3)} + \left(L_4 + \frac{L_5}{2} \right)\sin{(q_2+q_3+q_4)} \right)
    \\
    g_3 &= \frac{\partial P}{\partial q_3} =
    m_3g\frac{L_3}{2}\sin{(q_2+q_3)} +
    m_4g\left( L_3\sin{(q_2 + q_3)} + \frac{L_4}{2}\sin{(q_2+q_3+q_4)} \right)\\&+
    m_5g\left(  L_3\sin{(q_2 + q_3)} + \left(L_4 + \frac{L_5}{2} \right)\sin{(q_2+q_3+q_4)} \right)
    \\
    g_4 &=\frac{\partial P}{\partial q_4} = 
    m_4g\frac{L_4}{2}\sin{(q_2+q_3+q_4)}+
    m_5g\left(L_4 + \frac{L_5}{2} \right)\sin{(q_2+q_3+q_4)}
    \\
    g_5 &= \frac{\partial P}{\partial q_5} = 0
    \\
    g(q) &= [g_1,g_2,g_3,g_4,g_5]^T
 \end{align*}
This is the gravity components that each joint will \textit{feel} from the other links and by adding this to a PD controller it will compensate for this disturbance. 

\subsubsection{Test of controller}
Now that a controller is in place it is time to test it. The first thing to test is the gravity compensation. The best way to view the results is to watch the robot it is in a stationary state the only input that are sent into the individual joint torque controllers should be the data computed only by the gravity compensation part. Some random desired joint angles is chosen and the following results can be viewed in \tabref{table:gravity}.\\

\begin{table}[htbp]
\centering
\caption{Test results of the precision of the gravity compensation}
\label{table:gravity}
    \begin{tabular}{l c c r}
        \toprule
        Joint  &  $g_i$ & $u_i$ & $u_i-g_i$\\
        \midrule
        1 & 0 & 0 & 0\\
        2 & -0.7720  & -0.7760  & -0.0040 \\
        3 &-0.4226 & -0.4191 & 0.0035 \\
        4 & -0.1870 &-0.1871 & -0.0001\\
        5 & 0 & 0 & 0\\
        \bottomrule
    \end{tabular}
\end{table}

 One can see that the results are good. One can see that the PD part of the controller must some work which means that the end effector will not be completely at its desired position. The biggest error is in the second joint and for this configuration $0.0022 rad = 0.1261 deg$ which corresponds to an error of $0.0003$ in the xyz world frame. \\
 
Now that we know that the gravity compensation is working we can start to test the controller. The gain matrices $K_p$ and $K_d$ are implemented as positive definite diagonal matrices.

\begin{figure*}[htbp]
    \centering
    \begin{subfigure}[htbp]{0.45\textwidth}
        \centering
        \includegraphics[width = 1.15\linewidth]{img/LSq.eps}
        \caption{cap5}
        \label{fig:LSq}
    \end{subfigure}
    ~ 
    \begin{subfigure}[htbp]{0.45\textwidth}
        \centering
        \includegraphics[width = 1.15\linewidth]{img/LSerror.eps}
        \caption{cap4}
    \end{subfigure}
    ~
    \centering
    \begin{subfigure}[htbp]{0.45\textwidth}
        \centering
        \includegraphics[width = 1.15\linewidth]{img/LSqdot.eps}
        \caption{cap3}
    \end{subfigure}
    ~ 
    \begin{subfigure}[htbp]{0.45\textwidth}
        \centering
        \includegraphics[width = 1.15\linewidth]{img/LSu.eps}
        \caption{cap2}
    \end{subfigure}
    ~
    \begin{subfigure}[htbp]{0.45\textwidth}
        \centering
        \includegraphics[width = 1.15\linewidth]{img/LSgrav.eps}
        \caption{cap4}
    \end{subfigure}
    \caption{CaP1}
    \label{fig:LS}
\end{figure*}

In \figref{fig:LS} different data is plotted from a random configuration to a some kind of inverse position such that every joint get to move. The step is rather large and because the intention of the robot arm is to do set point tracking some overshoot is therefore accepted for this case. By looking at the plots, the results looks good. One thing that could be better is the joint velocity of last joint which seems a bit unstable. Additional tuning to try to avoid the ugly input and joint velocity of the fifth joint results in slow convergence of the joint angle. Since the moments of inertia is very low and Gazebo handles low inertias very bad, so this effect is assumed to be because of this and the when implementing this on the real robot it is expected that this effect will not be a problem. From \figref{fig:LSq} one can see $q_5$ converges rather smooth and the gains will be used for further testing. It may be worth to mention that when doing setpoint tracking the steps are not that large and the gains can be altered for better performance.  








\section{Kinematics}


\subsection{Forward Kinematics}
    
\begin{figure}[htbp]
  \centering
  \includegraphics[width=.9\textwidth]{img/DHconv.png}
  \caption{Kinematic scheme of the manipulator. Source \cite{Kinematics}}
  \label{fig:dhf}
\end{figure}

The forward kinematics states the relationship between the end effector and the individual joints. One easy way to get the forward kinematics is to use the Denavit-Hartenberg(DH) convention. \cite{spong} states that each homogenous transformation $A_i$ is represented as a product of four basic transformations: 


$$
A_i = 
    \begin{bmatrix}
        c_{\theta_i} & -s_{\theta_i}c_{\alpha_i} & s_{\theta_i}s_{\alpha_i} & a_ic_{\theta_i}\\
        s_{\theta_i} & c_{\theta_i}c_{\alpha_i} & -c_{\theta_i}s_{\alpha_i} & a_is_{\theta_i}\\
        0 & s_{\alpha_i} & c_{\alpha_i} &d_i\\
        0 & 0 & 0 & 1
    \end{bmatrix}
$$
where $c_{\theta_i} = \cos{(\theta_i)}$ and $s_{\theta_i} = \sin{(\theta_i)}$, and the same for $\alpha$. 
By looking at \figref{fig:dhf} the following DH parametres are found:
\begin{center}
    \begin{tabular}{|c|c|c|c|c|}
         \hline
         Link & $a_i$ & $\alpha_i$ & $d_i$ & $\theta_i$ \\ \hline
         1 & 0 & $-\frac{\pi}{2}$ & $d_1$ & $q_1$ \\
         2 & $a_2$ & 0 & 0 & $q_2$ \\ 
         3 & $a_3$ & 0 & 0 & $q_3$\\
         4 & 0 & $\frac{\pi}{2}$ & 0 & $q_4$\\
         5 & 0 & 0 & $d_5$ & $q_5$\\
         \hline
    \end{tabular}
\end{center}

% d_1 = 0.0506
% a_2 = 0.0506 + 0.0206 + 0.0635 = 0.1347
% a_3 = 0.0506 + 0.0206 = 0.0712
% d_5 = 0.0506 + 0.0206 + 0.0253 + 0.08 = 0.1765

where $d_1 = 0.0506$, $a_2 = 0.1347$, $a_3 = 0.0712$ and $d_5 = 0.1765$ for the model. The real values need to be measured properly since the data sheet of the robot is insufficient. 
Now it is possible to calculate $A_i$ for each joint. Using Matlab:

\begin{align*}
A_1 &= \begin{bmatrix} 
            c_1 & 0 & -s_1 & 0\\
            s_1 & 0 & c_1 & 0\\
            0 & -1 & 0 & d_1\\
            0 & 0 & 0 & 1
        \end{bmatrix},
A_2 = \begin{bmatrix} 
            c_2 & -s_2 & 0 & a_2c_2\\
            s_2 & c_2 & 0 & a_2s_2\\
            0 & 0 & 1 & 0\\
            0 & 0 & 0 & 1
        \end{bmatrix},
A_3 = \begin{bmatrix} 
            c_3 & -s_3 & 0 & a_3c_3\\
            s_3 & c_3 & 0 & a_3s_3\\
            0 & 0 & 1 & 0\\
            0 & 0 & 0 & 1
        \end{bmatrix}\\
A_4 &= \begin{bmatrix} 
            c_4 & 0 & s_4 & 0\\
            s_4 & 0 & -s_4 & 0\\
            0 & 1 & 0 & 0\\
            0 & 0 & 0 & 1
        \end{bmatrix},
A_5 = \begin{bmatrix} 
            c_5 & -s_5 & 0 & 0\\
            s_5 & c_5 & 0 & 0\\
            0 & 0 & 1 & d_5 \\
            0 & 0 & 0 & 1
        \end{bmatrix}
\end{align*}

 and then calculate $T_i^0$ using Matlab:
\begin{subequations}
\begin{align}
    T_1^0 &= A_1 =
    \begin{bmatrix}\label{eq:T1}
        c_1 & 0 & -s_1 & 0\\
        s_1 & 0 & c_1 & 0\\
        0 & -1 & 0 & d_1\\
        0 & 0 & 0 & 1
    \end{bmatrix}\\
    T_2^0 &= A_1A_2 =
    \begin{bmatrix}\label{eq:T2}
        c_1c_2 & -c_1s_2 & -s_1 & a_2c_1c_2\\
        s_1c_2 & -s_1s_2 & c_1 & a_2s_1c_2\\
        -s_2 & -c_2 & 0 & d_1 - a_2s_2\\
        0 & 0 & 0 & 1
    \end{bmatrix}\\
    T_3^0 &= A_1A_2A_3=
    \begin{bmatrix}\label{eq:T3}
        c_{23}c_1 & -c_1s_{23} & -s_1 & c_1(a_3c_{23} + a_2c_2)\\
        c_{23}s_1 & -s_1s_{23} & c_1 & s_1(a_3c_{23} + a_2c_2)\\
        -s_{23} & -c_{23} & 0 & d_1 - a_3s_{23}-a_2s_2\\
        0 & 0 & 0 & 1
    \end{bmatrix}\\
    T_4^0 &= A_1A_2A_3A_4=
    \begin{bmatrix}\label{eq:T4}
        c_1c_{234} & -s_1 & c_1s_{234} & c_1(a_3c_{23} + a_2c_2)\\
        s_1c_{234} & c_1 & s_1s_{234} & s_1(a_3c_{23} + a_2c_2)\\
        -s_{234} & 0 & c_{234} & d_1 - a_3s_{23} - a_2s_2\\
        0 & 0 & 0 & 1
    \end{bmatrix}\\
    \begin{split}
        T_5^0 &= A_1A_2A_3A_4A_5\\ &=
        \begin{bmatrix}\label{eq:T5}
            c_1c_{234}c_5 - s_1s5 & -s_1c_5 - c_1c_{234}s_5 & c_1s_{234} & c_1(a_3c_{23} + a_2c_2 + d_5s_{234})\\
            s_1c_{234}c_5 + c_1s_5 & c_1c_5 - s_1c_{234}s_5 & s_1s_{234} & s_1(a_3c_{23} + a_2c_2 + d_5s_{234})\\
            -s_{234}c_5 & s_{234}s_5 & c_{234} & d_1 - a_3s_{23} - a_2s_2 + d_5c_{234}\\
            0 & 0 & 0 & 1
        \end{bmatrix}
    \end{split}
 \end{align}
\end{subequations}
where $s_{ijk} = \sin{(q_i + q_j + q_k)}$ and the same for $c_{ijk}$. The $T_i^0$ matrix can be sectioned into \begin{align*}
 T_i^0 = 
    \begin{bmatrix}
        \bm{R}(\bm{q}) & \bm{p}(\bm{q})\\
        \bm{0}^T & 1
    \end{bmatrix}    
\end{align*}


%-----------------------------------------------------------------------------------------
\begin{comment}
\begin{align*}
    T^0_5 &= A_1A_2A_3A_4A_5\\
    &= 
    \begin{bmatrix}
        c_1c_{234}c_5 + s_1s_5 & -c_1c_{234}s_5+s_1c_5 & -c_1s_{234} & c_1(-d_5s_{234} + a_3c_{23} + a_2c_2)\\
        c_1c_{234}c_5 - s_1s_5 & -s_1c_{234}s_5-c_1c_5 & -s_1s_{234} & s_1(-d_5s_{234} + a_3c_{23} + a_2c_2) \\
        -s_{234}c_5 & s_{234}s_5 & -c_{234} &d_1 - a_2s_2 - a_3s_{23} - d_5c_{234}\\
        0 & 0 & 0 & 1\\
    \end{bmatrix}\\
    &=
    \begin{bmatrix}
        \bm{R}(\bm{q}) & \bm{p}(\bm{q})\\
        \bm{0}^T & 1
    \end{bmatrix}
\end{align*}
\end{comment}
%-----------------------------------------------------------------------------------------

\subsection*{Inverse Kinematics}
\cite{Siciliano} states that one can use the Jacobian of the system to calculate the inverse kinematics:

\begin{align}\label{eq:algo}
\dot{\bm{e}} = \dot{\bm{x}}_d - \bm{J}_A(\bm{q})\dot{\bm{q}}
\end{align}

In \figref{fig:inverseAlgo} the inverse kinematics algorithm is stated. From the figure one can see that 
$$
\dot{\bm{q}} = \bm{J}_A^{-1}(\bm{q})(\dot{\bm{x}}_d + \bm{K}e)
$$
where K is a positive definite diagonal matrix which makes the resulting system \eqref{eq:algo} into the linear system
\begin{align*}
    \dot{\bm{e}} + \bm{K}e = \bm{0}
\end{align*}


\begin{figure}[htbp]
  \centering
  \includegraphics[width=.9\textwidth]{img/inverseKin.png}
  \caption{Inverse kinematics algotihm with Jacobian inverse. Source \cite{Siciliano}.}
  \label{fig:inverseAlgo}
\end{figure}


\subsubsection*{Jacobian}
As we already know the forward/direct kinematics can be written as:
\begin{align*}
    \bm{T}(\bm{q}) = 
    \begin{bmatrix}
        \bm{R}(\bm{q}) & \bm{p}(\bm{q})\\
        \bm{0}^T & 1
    \end{bmatrix}
\end{align*}
we want to express the linear velocity $\dot{\bm{p}}$ and angular velocity $\bm{\omega}$ as a function of the joint velocities $\dot{\bm{q}}$. In \cite{Siciliano} the relations is states as:

\begin{equation}
    \begin{aligned}\label{eq:velo}
        \dot{\bm{p}} &= \bm{J}_P(\bm{q})\dot{\bm{q}}\\
        \bm{\omega} &= \bm{J}_O(\bm{q})\dot{\bm{q}}
    \end{aligned}
\end{equation}

where $\bm{J}_O$ with dimensions (3 $\times$ n) is the relation between the joint velocities $\dot{\bm{q}}$ and the end-effector linear velocity $\dot{\bm{p}}$, and the (3 $\times$ n) matrix $\bm{J}_O$ is the relation between the joint velocities $\dot{\bm{q}}$ and the end-effector angular velocity $\bm{\omega}$. \eqref{eq:velo} can be written as

\begin{align*}
    \bm{v_e} = 
    \begin{bmatrix}
        \dot{\bm{p}} \\ \bm{\omega}
    \end{bmatrix}
    = \bm{J}(\bm{q})\dot{\bm{q}}
\end{align*}
where
\begin{align*}
    \bm{J} = 
    \begin{bmatrix}
        \bm{J}_P \\ \bm{J}_O
    \end{bmatrix}
\end{align*}

which is the matrix that \cite{Siciliano} calls the geometric Jacobian. The elements of 
$$
\bm{J} = 
\begin{bmatrix}
    \bm{j}_{P1} & & \bm{j}_{Pn}\\
    &...&\\
    \bm{j}_{O1} & & \bm{j}_{On}
\end{bmatrix}
$$
can be calculated in the following way:
\begin{align*}
    \begin{bmatrix}
        \bm{j}_{Pi}\\\bm{j}_{Oi}
    \end{bmatrix}
    =
    \begin{cases}
        \begin{bmatrix} \bm{z}_{i-1}\\ \bm{0} \end{bmatrix} & \text{for a prismatic joint}\\
        \begin{bmatrix} \bm{z}_{i-1} \times (\bm{p}_e-\bm{p}_{i-1}) \\ \bm{z}_{i-1} \end{bmatrix} & \text{for a revolute joint}
    \end{cases}
\end{align*}

Since our manipulator only has revolute joints, the geometric Jacobian becomes

\begin{align*}
    \bm{J}(\bm{q}) = 
    \begin{bmatrix}
        \bm{z}_0 \times (\bm{p}_5-\bm{p}_0) & 
        \bm{z}_1 \times (\bm{p}_5-\bm{p}_1) & 
        \bm{z}_2 \times (\bm{p}_5-\bm{p}_2) & 
        \bm{z}_3 \times (\bm{p}_5-\bm{p}_3) & 
        \bm{z}_4 \times (\bm{p}_5-\bm{p}_4) \\
        \bm{z}_0 &
        \bm{z}_1 &
        \bm{z}_2 &
        \bm{z}_3 &
        \bm{z}_4
    \end{bmatrix}
\end{align*}
From when the forward kinematics were calculated each position vector $\bm{p}_i$ can be directly obtained from the equations \eqref{eq:T1} - \eqref{eq:T5}:



\begin{align*}
    \bm{p_0} = \begin{bmatrix} 0 \\ 0 \\ 0 \end{bmatrix}    \quad
    \bm{p_1} = \begin{bmatrix} 0 \\ 0 \\ d_1\end{bmatrix}    \quad
    \bm{p_2} = \begin{bmatrix} a_2c_1c_2\\ a_2s_1c_2\\ d_1 - a_2s_2\end{bmatrix}   \quad 
    \bm{p_3} = \begin{bmatrix} c_1(a_3c_{23} + a_2c_2) \\ s_1(a_3c_{23} + a_2c_2) \\ d_1 - a_3s_{23}-a_2s_2 \end{bmatrix}  \\  
    \bm{p_4} = \begin{bmatrix} c_1(a_3c_{23} + a_2c_2) \\ s_1(a_3c_{23} + a_2c_2) \\ d_1 - a_3s_{23}-a_2s_2\end{bmatrix}  \quad  
    \bm{p_5} = \begin{bmatrix} c_1(a_3c_{23} + a_2c_2 + d_5s_{234}) \\ s_1(a_3c_{23} + a_2c_2 + d_5s_{234}) \\ d_1 - a_3s_{23} - a_2s_2 + d_5c_{234} \end{bmatrix}    
\end{align*}

The next step is to find $z_{i-1}$. \cite{Siciliano} states that $\bm{z}_{i-1}$ is given by the third column of the rotation matrix $\bm{R}_{i-1}^0$. $\bm{R}_{i-1}^0$ is already given in $T_i^0$, By looking at \eqref{eq:T1} - \eqref{eq:T5} the following values of $z_{i-1}$ is given:
\begin{align*}
    z_0 &= \begin{bmatrix}0\\0\\1\end{bmatrix},
    z_1 = \begin{bmatrix}-s_1\\c_1\\0\end{bmatrix},
    z_2 = \begin{bmatrix}-s_1\\c_1\\0\end{bmatrix},
    z_3 = \begin{bmatrix}-s_1\\c_1\\0\end{bmatrix},
    z_4 = \begin{bmatrix}c_1s_{234}\\s_1s_{234}\\c_{234}\end{bmatrix}
\end{align*}

now we got everything needed to compute the geometric Jacobian. The symbolic calculation is done in Matlab:


\begin{align*}
    \bm{J}(\bm{q}) &= \\
    &\begin{bmatrix}
        -s_1(a_3c_{23} + a_2c_{2} + d_5s_{234}) & 
        -c_1(a_3s_{23} + a_2s_{2} - d_5c_{234}) & 
        -c_1(a_3s_{23} - d_5c_{234})            & 
        c_1d_5c_{234}                           & 
        0\\
        c_1(a_3c_{23} + a_2c_{2} + d_5s_{234})  & 
        -s_1(a_3s_{23} + a_2s_{2} - d_5c_{234}) & 
        -s_1(a_3s_{23} - d_5c_{234})            & 
        s_1d_5c_{234}                           & 
        0\\
        0                                       &
        -a_3c_{23}- a_2c_2 - d_5s_{234}         &
        -a_3c_{23} - d_5s_{234}                 &
        -d_5s_{234}                             &
        0\\
        0                                       &
        -s_1                                    &
        -s_1                                    &
        -s_1                                    &
        c_1s_{234}\\
        0                                       &
        c_1&
        c_1&
        c_1&
        s_1s_{234}\\
        1& 0 & 0 & 0 & c_{234}
    \end{bmatrix}
\end{align*}
which has the full rank of $5$. 
\subsubsection*{Analytical Jacobian}
To use the algorithm in \figref{fig:inverseAlgo} the analytical Jacobian is needed. In \cite{Siciliano} the following relationship is given
\begin{align*}
    \bm{J}_A =
    \begin{bmatrix}
        \bm{I} & \bm{0}\\ 0 & \bm{T}^{-1}(\bm{\phi_e})
    \end{bmatrix}
    \bm{J}(\bm{q})
\end{align*}

where $\bm{\phi_e} = [\phi,\theta,\psi]^T$ is the orientation of the end-effector frame relative to the base frame given by the Euler angles ZYZ. From \eqref{eq:T5} the rotation matrix from the base frame to end-effector is
\begin{align*}
    \bm{R}_5^0 &= 
    \begin{bmatrix}
        r_{11} & r_{12} & r_{13}\\
        r_{21} & r_{22} & r_{23}\\
        r_{31} & r_{32} & r_{33}
    \end{bmatrix}
    =
    \begin{bmatrix}
        c_1c_{234}c_5 - s_1s_5 & -s_1c_5 - c_1c_{234}s_5 & c_1s_{234}\\
        s_1c_{234}c_5 + c_1s_5 & c_1c_5 - s_1c_{234}s_5 & s_1s_{234}\\
        -s_{234}c_5 & s_{234}s_5 & c_{234} 
    \end{bmatrix}
\end{align*}

The ZYZ Euler angles are then


\begin{align*}
    \phi &= atan2(r_{21},r_{11}) = atan2(s_1c_{234}c_5 + c_1s_5,c_1c_{234}c_5 - s_1s_5)\\
    \theta &= atan2\left(-r_{31},-\sqrt{r_{32}^2+r_{33}^2}\right) = atan2\left(s_{234}c_5,-\sqrt{s_{234}s_5^2+c_{234}^2}\right)\\
    \psi &= atan2(r_{32},r_{33}) = atan2(s_{234}s_5,c_{234})
\end{align*}

The angular velocity $\bm{\omega}_e$ and $\bm{T}(\bm{\alpha})$ is given as

\begin{align*}
    \bm{\omega} = 
    \begin{bmatrix}
        0 & -s_\phi & c_\phi s_\theta\\
        0 & c_\phi & s_\phi s_\theta\\
        1 & 0 & c_\theta
    \end{bmatrix}
    \begin{bmatrix}
        \dot{\phi}\\\dot{\theta}\\\dot{\psi}
    \end{bmatrix}
    =
    \bm{T}(\bm{\phi}_e)\dot{\bm{\phi}}_e
\end{align*}
The determinant of $\bm{T}$ is $-s_\theta$ which means that one cannot invert for $\theta = 0,\pi$. This singularity is also the singularity of the geometric Jacobian. 







%\begin{comment}
If the desired position is $p$ and the desired orientation is $R$. Then in \cite{Kinematics}, the inverse kinematics are given as: 

\begin{align*}
    q_1 &= \tan^{-1}{\left(\frac{p_y}{p_x}\right)}\\
    q_2 &= atan2\left( a(a_2+a_3c_3) - ba_3s_3, aa_3s_3 + b(a_2+a_3c_3) \right)\\%atan2
    q_3 &= \cos^{-1}{\left(\frac{a^2+b^2-a^2_2-a^2_3}{2a_2a_3}\right)}\\
    q_4 &= q_{234} - q_2 - q_3\\
    q_5 &= c_{234}q_1-2atan(R_{21},R_{11})
\end{align*}

where $a = d_1 - d_5c_{234}-p_z$, $b = p_xc_1 + p_ys_1+d_5s_{234}$ and $-\frac{\pi}{2}<q_1 < \frac{\pi}{2}$. $q_{234} = atan2\left(\frac{p_x}{c_1p_x+s_1p_y})\right)$

%\cite{Siciliano}
%\end{comment}


\section{Inverse Kinematics}
\section{Motion planning}